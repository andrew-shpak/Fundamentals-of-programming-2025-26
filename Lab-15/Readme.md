# Лабораторна робота 15 — Основи класів, конструктори та деструктори

У цій лабораторній роботі ви навчитеся створювати класи, працювати з інкапсуляцією, конструкторами та деструкторами. Лабораторна складається з двох частин: базові концепції класів та робота з конструкторами/деструкторами.

---

## Частина 1 — Основи класів

### Завдання 1 — Простий клас Point з конструктором
Створіть клас `Point` з двома приватними полями `x` та `y` типу `double`. Реалізуйте:
- Конструктор `Point(double x, double y)` — ініціалізація координат
- `double GetX() const` та `double GetY() const` — отримання координат
- `void Print() const` — виведення точки у форматі `(x, y)`
- (Опціонально) `void SetX(double value)` та `void SetY(double value)` — зміна координат після створення

Приклад використання:
```cpp
Point p(3.5, 4.2);
p.Print();
std::cout << "X: " << p.GetX() << ", Y: " << p.GetY() << std::endl;
```
Приклад виводу:
```
(3.5, 4.2)
X: 3.5, Y: 4.2
```

---

### Завдання 2 — Клас Rectangle з конструктором
Реалізуйте клас `Rectangle` з приватними полями `width` та `height` типу `double`. Додайте:
- Конструктор `Rectangle(double w, double h)` — ініціалізація розмірів
- `double GetWidth() const` та `double GetHeight() const` — отримання розмірів
- `double CalculateArea() const` — обчислення площі
- `double CalculatePerimeter() const` — обчислення периметру

Приклад використання:
```cpp
Rectangle rect(5.0, 3.0);
std::cout << "Площа: " << rect.CalculateArea() << std::endl;
std::cout << "Периметр: " << rect.CalculatePerimeter() << std::endl;
```
Приклад виводу:
```
Площа: 15.0
Периметр: 16.0
```

---

### Завдання 3 — Клас Student з конструктором
Створіть клас `Student` з приватними полями:
- `std::string name`
- `int age`
- `double gpa` (середній бал)

Реалізуйте:
- Конструктор `Student(const std::string& name, int age, double gpa)` — ініціалізація студента
- Геттери для всіх полів (`GetName()`, `GetAge()`, `GetGpa()`)
- Метод `void PrintInfo() const` — виведення інформації про студента
- (Опціонально) Сеттери для зміни даних після створення

Приклад використання:
```cpp
Student s("Іван Петренко", 20, 4.5);
s.PrintInfo();
```
Приклад виводу:
```
Ім'я: Іван Петренко
Вік: 20
Середній бал: 4.5
```

---

### Завдання 4 — Клас BankAccount з конструктором
Реалізуйте клас `BankAccount` з приватними полями:
- `std::string accountNumber`
- `double balance`

Додайте:
- Конструктор `BankAccount(const std::string& number, double initialBalance = 0.0)` — створення рахунку
- `void Deposit(double amount)` — поповнення рахунку (перевіряти на додатність)
- `bool Withdraw(double amount)` — зняття коштів (перевіряти достатність балансу)
- `double GetBalance() const` — отримання балансу
- `std::string GetAccountNumber() const` — отримання номеру рахунку
- `void PrintStatement() const` — виведення інформації про рахунок

Приклад використання:
```cpp
BankAccount account("UA123456", 1000.0);
account.Withdraw(250.0);
account.PrintStatement();
```
Приклад виводу:
```
Рахунок: UA123456
Баланс: 750.0
```

---

### Завдання 5 — Використання this pointer та method chaining
Створіть клас `Point` з приватними полями `x` та `y`. Реалізуйте:
- Конструктор `Point(double x = 0.0, double y = 0.0)` — ініціалізація з параметрами за замовчуванням
- `Point& SetCoordinates(double x, double y)` — встановлює координати і повертає посилання на поточний об'єкт через `return *this`
- `Point& Move(double dx, double dy)` — зсуває точку на (dx, dy) і повертає `*this`
- `void Print() const` — виведення точки

Це дозволить використовувати method chaining:
```cpp
Point p;
p.SetCoordinates(1.0, 2.0).Move(2.0, 2.0).Print();
```
Приклад виводу:
```
(3.0, 4.0)
```

---

### Завдання 6 — Константні методи та об'єкти
Створіть клас `Circle` з приватним полем `radius`. Реалізуйте:
- Конструктор `Circle(double r)` — ініціалізація радіусу
- `double GetRadius() const` — отримання радіусу
- `double CalculateArea() const` — обчислення площі (π × r²)
- `double CalculateCircumference() const` — обчислення довжини кола (2 × π × r)

Використовуйте константу `M_PI` з `<cmath>`.

Приклад використання:
```cpp
const Circle c(5.0);
std::cout << "Площа: " << c.CalculateArea() << std::endl;
std::cout << "Довжина: " << c.CalculateCircumference() << std::endl;
// c.SetRadius(10.0);  // Помилка компіляції, якщо додати сеттер!
```
Приклад виводу:
```
Площа: 78.5398
Довжина: 31.4159
```

---

## Частина 2 — Конструктори та деструктори

### Завдання 7 — Конструктори за замовчуванням з параметрами за замовчуванням
Створіть клас `Point3D` для тривимірних точок з полями `x`, `y`, `z`. Реалізуйте:
- Конструктор з параметрами за замовчуванням: `Point3D(double x = 0.0, double y = 0.0, double z = 0.0)`
- Геттери для всіх координат
- Метод `void Print() const` — виведення у форматі `(x, y, z)`
- Метод `double DistanceFromOrigin() const` — обчислення відстані від початку координат

Один конструктор може працювати як конструктор за замовчуванням і параметризований:
```cpp
Point3D p1;              // (0, 0, 0) - викликає конструктор за замовчуванням
Point3D p2(1.0);         // (1, 0, 0)
Point3D p3(1.0, 2.0);    // (1, 2, 0)
Point3D p4(1.0, 2.0, 3.0); // (1, 2, 3)
p1.Print();
p2.Print();
```
Приклад виводу:
```
(0.0, 0.0, 0.0)
(1.0, 0.0, 0.0)
```

---

### Завдання 8 — Конструктор копіювання
Створіть клас `Array` для динамічного масиву цілих чисел з приватними полями:
- `int* data`
- `size_t size`

Реалізуйте:
- Конструктор `Array(size_t n)` — створює масив розміру n
- Конструктор копіювання `Array(const Array& other)` — виконує глибоке копіювання
- Деструктор `~Array()` — звільняє пам'ять
- Метод `void Set(size_t index, int value)` та `int Get(size_t index) const`

Приклад використання:
```cpp
Array arr1(5);
arr1.Set(0, 10);
Array arr2 = arr1;  // Глибоке копіювання
arr2.Set(0, 20);
```
Результат: `arr1` має 10, `arr2` має 20 на позиції 0.

---

### Завдання 9 — Деструктор та RAII
Створіть клас `FileLogger` для логування в файл:
- Приватне поле `std::ofstream file`
- Конструктор `FileLogger(const std::string& filename)` — відкриває файл
- Деструктор `~FileLogger()` — закриває файл
- Метод `void Log(const std::string& message)` — записує повідомлення

Продемонструйте, що файл автоматично закривається при виході з області видимості.

Приклад використання:
```cpp
{
    FileLogger logger("log.txt");
    logger.Log("Програма запущена");
    logger.Log("Виконується обчислення");
}  // Файл автоматично закривається тут
```

---

### Завдання 10 — Список ініціалізації членів
Створіть клас `Person` з приватними полями:
- `const std::string name` (константне поле!)
- `int age`
- `std::string& alias` (посилання!)

Реалізуйте конструктор, який ініціалізує всі поля через список ініціалізації:
```cpp
Person(const std::string& n, int a, std::string& al)
    : name(n), age(a), alias(al) {}
```

Поясніть, чому константні поля та посилання можна ініціалізувати тільки через список ініціалізації.

---

### Завдання 11 — Делегуючі конструктори
Створіть клас `Rectangle` з приватними полями `width` та `height`. Реалізуйте три конструктори, що використовують делегування (C++11):
- Конструктор за замовчуванням `Rectangle()` — делегує до конструктора `Rectangle(double side)` зі значенням 1.0
- Конструктор `Rectangle(double side)` — делегує до `Rectangle(double w, double h)` з однаковими сторонами
- Головний конструктор `Rectangle(double w, double h)` — ініціалізує поля через список ініціалізації

Реалізація:
```cpp
Rectangle() : Rectangle(1.0) {}
Rectangle(double side) : Rectangle(side, side) {}
Rectangle(double w, double h) : width(w), height(h) {}
```

Додайте методи `GetArea()` та `Print()`.

Приклад використання:
```cpp
Rectangle r1;           // 1×1 квадрат
Rectangle r2(5.0);      // 5×5 квадрат
Rectangle r3(3.0, 4.0); // 3×4 прямокутник
r1.Print();
r2.Print();
r3.Print();
```
Приклад виводу:
```
Rectangle: 1.0 x 1.0, Area: 1.0
Rectangle: 5.0 x 5.0, Area: 25.0
Rectangle: 3.0 x 4.0, Area: 12.0
```

---

### Завдання 12 — Лічильник об'єктів
Створіть клас `Counter` зі статичним полем `objectCount`, яке підраховує кількість створених об'єктів:
- Конструктор за замовчуванням збільшує лічильник
- Конструктор копіювання збільшує лічильник
- Деструктор зменшує лічильник
- Статичний метод `static int GetCount()` повертає кількість активних об'єктів

Приклад використання:
```cpp
std::cout << Counter::GetCount() << std::endl;  // 0
{
    Counter c1;
    Counter c2;
    std::cout << Counter::GetCount() << std::endl;  // 2
    {
        Counter c3 = c1;
        std::cout << Counter::GetCount() << std::endl;  // 3
    }
    std::cout << Counter::GetCount() << std::endl;  // 2
}
std::cout << Counter::GetCount() << std::endl;  // 0
```

---

## Примітки

### Загальні рекомендації:
- Використовуйте модифікатори доступу правильно: приватні поля, публічні методи
- Завжди робіть геттери константними (`const`)
- Дотримуйтесь принципу інкапсуляції — не надавайте прямий доступ до полів
- Використовуйте списки ініціалізації для конструкторів (ефективніше, ніж присвоєння в тілі)

### Для конструкторів та деструкторів:
- Завжди звільняйте динамічну пам'ять у деструкторі
- Реалізуйте глибоке копіювання в конструкторі копіювання для класів з динамічною пам'яттю
- Слідкуйте за правилом трьох (Rule of Three): якщо потрібен деструктор, потрібні конструктор копіювання та оператор присвоєння
- Використовуйте RAII (Resource Acquisition Is Initialization) для автоматичного управління ресурсами
- Перевіряйте витоки пам'яті за допомогою valgrind або подібних інструментів

### Компіляція:
```bash
g++ -std=c++20 -Wall -Wextra -pedantic src/task01_point.cpp -o build/task01_point
```
