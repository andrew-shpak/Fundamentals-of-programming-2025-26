# Лабораторна робота 16 — Основи наслідування

У цій лабораторній роботі ви навчитеся працювати з наслідуванням класів у C++, розумітися в ієрархіях класів, ланцюжках конструкторів та модифікаторах доступу. Лабораторна складається з двох частин: базове наслідування та розширені концепції.

---

## Частина 1 — Базове наслідування

### Завдання 1 — Простий приклад наслідування
Створіть базовий клас `Animal` з приватним полем `std::string name` та публічними методами:
- `Animal(const std::string& n)` — конструктор
- `void SetName(const std::string& n)` та `std::string GetName() const`
- `void Eat() const` — виводить "Тварина їсть"

Створіть похідний клас `Dog`, який успадковує `Animal` та додає метод:
- `void Bark() const` — виводить "Гав-гав!"

Приклад використання:
```cpp
Dog dog("Рекс");
dog.Eat();
dog.Bark();
```
Приклад виводу:
```
Тварина їсть
Гав-гав!
```

---

### Завдання 2 — Ланцюжок конструкторів
Розширте приклад з завдання 1. Додайте до класу `Animal` приватне поле `int age` та публічний метод `int GetAge() const`.

Створіть конструктор для `Dog`:
```cpp
Dog(const std::string& n, int a) : Animal(n), age(a) {}
```

Додайте метод `void PrintInfo() const` у класі `Dog`, який виводить ім'я та вік.

Приклад використання:
```cpp
Dog dog("Рекс", 3);
dog.PrintInfo();
```
Приклад виводу:
```
Ім'я: Рекс
Вік: 3 років
```

---

### Завдання 3 — Захищені члени класу (protected)
Створіть базовий клас `Shape` з захищеним полем `std::string color` та публічними методами:
- `Shape(const std::string& c)` — конструктор
- `std::string GetColor() const` — отримання кольору
- `void SetColor(const std::string& c)` — встановлення кольору

Створіть похідний клас `Circle` з приватним полем `double radius` та методами:
- `Circle(const std::string& c, double r)` — конструктор
- `void PrintInfo() const` — виводить колір та радіус

Продемонструйте, що похідний клас має доступ до захищеного поля `color`.

Приклад використання:
```cpp
Circle circle("червоний", 5.0);
circle.PrintInfo();
```
Приклад виводу:
```
Коло: червоний колір, радіус 5.0
```

---

### Завдання 4 — Перевизначення методів
Створіть базовий клас `Vehicle` з методом `void Move() const`, який виводить "Транспортний засіб рухається".

Створіть похідні класи:
- `Car` — перевизначає `Move()` для виводу "Автомобіль їде по дорозі"
- `Boat` — перевизначає `Move()` для виводу "Човен пливе по воді"
- `Plane` — перевизначає `Move()` для виводу "Літак летить у небі"

Приклад використання:
```cpp
Car car;
Boat boat;
Plane plane;
car.Move();
boat.Move();
plane.Move();
```
Приклад виводу:
```
Автомобіль їде по дорозі
Човен пливе по воді
Літак летить у небі
```

---

### Завдання 5 — Відношення is-a
Створіть ієрархію класів для геометричних фігур:
- Базовий клас `Shape2D` з чистими віртуальними методами `double GetArea() const` та `double GetPerimeter() const`
- Похідний клас `Rectangle` з полями `width` та `height`
- Похідний клас `Triangle` з полями `a`, `b`, `c` (сторони трикутника)

Реалізуйте обчислення площі та периметру для обох похідних класів.

Приклад використання:
```cpp
Rectangle rect(5.0, 3.0);
Triangle tri(3.0, 4.0, 5.0);
std::cout << "Площа прямокутника: " << rect.GetArea() << std::endl;
std::cout << "Площа трикутника: " << tri.GetArea() << std::endl;
```
Приклад виводу:
```
Площа прямокутника: 15.0
Площа трикутника: 6.0
```

---

### Завдання 6 — Доступ до членів базового класу
Створіть базовий клас `Person` з захищеними полями `name` та `age`, а також публічними методами:
- `Person(const std::string& n, int a)` — конструктор
- `void PrintInfo() const` — виводить ім'я та вік

Створіть похідний клас `Employee` з приватним полем `std::string position` та методами:
- `Employee(const std::string& n, int a, const std::string& p)` — конструктор
- `void PrintInfo() const` — перевизначає метод базового класу, виводить ім'я, вік та посаду
- Використайте `Person::PrintInfo()` всередині методу для виклику версії базового класу

Приклад використання:
```cpp
Employee emp("Марія Іванова", 28, "Розробник");
emp.PrintInfo();
```
Приклад виводу:
```
Ім'я: Марія Іванова
Вік: 28 років
Посада: Розробник
```

---

## Частина 2 — Розширені концепції наслідування

### Завдання 7 — Багаторівневе наслідування
Створіть ієрархію класів з трьох рівнів:
- `LivingBeing` (жива істота) з полем `bool isAlive`
- `Animal` успадковує `LivingBeing`, додає поле `int numberOfLegs`
- `Mammal` (ссавець) успадковує `Animal`, додає поле `bool hasFur` (має хутро)

Кожен клас має конструктор та метод `PrintInfo()`, який виводить всю інформацію про об'єкт.

Приклад використання:
```cpp
Mammal cat(true, 4, true);
cat.PrintInfo();
```
Приклад виводу:
```
Жива істота: так
Кількість ніг: 4
Має хутро: так
```

---

### Завдання 8 — Вказівники базового класу на похідні об'єкти
Створіть базовий клас `Instrument` з методом `virtual void Play() const`, який виводить "Інструмент грає".

Створіть похідні класи:
- `Piano` — перевизначає `Play()` для виводу "Піаніно грає мелодію"
- `Guitar` — перевизначає `Play()` для виводу "Гітара грає акорди"
- `Drums` — перевизначає `Play()` для виводу "Барабани грають ритм"

Створіть масив вказівників базового класу та продемонструйте поліморфну поведінку:
```cpp
Instrument* orchestra[3];
orchestra[0] = new Piano();
orchestra[1] = new Guitar();
orchestra[2] = new Drums();

for (int i = 0; i < 3; ++i) {
    orchestra[i]->Play();
}
```

**Важливо**: не забудьте звільнити пам'ять!

---

### Завдання 9 — Віртуальні деструктори
Модифікуйте завдання 8, додавши:
- Віртуальний деструктор у базовому класі `Instrument`
- Деструктори у похідних класах, які виводять повідомлення про знищення об'єкта

Продемонструйте, що без віртуального деструктора деструктори похідних класів не викликаються при видаленні через вказівник базового класу.

Приклад виводу при правильній реалізації:
```
Знищено піаніно
Знищено інструмент
Знищено гітару
Знищено інструмент
Знищено барабани
Знищено інструмент
```

---

### Завдання 10 — Проблема зрізання об'єктів (object slicing)
Створіть базовий клас `Base` з полем `int baseValue` та похідний клас `Derived` з полем `int derivedValue`.

Продемонструйте проблему зрізання об'єктів:
```cpp
Derived d;
d.baseValue = 10;
d.derivedValue = 20;

Base b = d;  // Зрізання! derivedValue втрачається
```

Створіть функцію, яка приймає об'єкт за значенням та за посиланням, і поясніть різницю:
```cpp
void ProcessByValue(Base b);      // Зрізання
void ProcessByReference(Base& b); // Без зрізання
```

---

### Завдання 11 — Upcasting та Downcasting
Створіть ієрархію класів:
- Базовий клас `Animal` з віртуальним методом `void MakeSound() const`
- Похідні класи `Cat` та `Dog` з перевизначеними методами

Продемонструйте:
1. **Upcasting** (автоматичне перетворення похідного класу в базовий):
```cpp
Dog dog;
Animal* animal = &dog;  // Upcasting — безпечно
```

2. **Downcasting** (перетворення базового класу в похідний через `dynamic_cast`):
```cpp
Animal* animal = new Dog();
Dog* dog = dynamic_cast<Dog*>(animal);  // Успіх
Cat* cat = dynamic_cast<Cat*>(animal);  // nullptr
```

Поясніть, коли downcasting безпечний, а коли небезпечний.

---

### Завдання 12 — Практична ієрархія класів
Створіть повноцінну ієрархію класів для бібліотечної системи:

**Базовий клас `LibraryItem`:**
- Захищені поля: `title`, `author`, `year`
- Віртуальний метод `void DisplayInfo() const`
- Віртуальний деструктор

**Похідні класи:**
- `Book` з додатковим полем `int pages`
- `Magazine` з додатковим полем `int issueNumber`
- `DVD` з додатковим полем `int durationMinutes`

Реалізуйте:
- Конструктори для всіх класів
- Перевизначення `DisplayInfo()` для кожного типу
- Функцію `void PrintLibrary(LibraryItem** items, int count)`, яка виводить інформацію про всі елементи бібліотеки

Приклад використання:
```cpp
LibraryItem* library[3];
library[0] = new Book("Кобзар", "Т. Шевченко", 1840, 200);
library[1] = new Magazine("National Geographic", "Various", 2024, 5);
library[2] = new DVD("Inception", "C. Nolan", 2010, 148);

PrintLibrary(library, 3);

// Звільнення пам'яті
for (int i = 0; i < 3; ++i) {
    delete library[i];
}
```

---

## Примітки

### Загальні рекомендації:
- Використовуйте модифікатор `protected` для полів, до яких потрібен доступ у похідних класах
- Завжди викликайте конструктор базового класу в списку ініціалізації похідного класу
- Слідкуйте за порядком виклику конструкторів: спочатку базовий, потім похідний
- Порядок виклику деструкторів — зворотний: спочатку похідний, потім базовий

### Для віртуальних функцій:
- Завжди оголошуйте деструктор базового класу віртуальним, якщо плануєте наслідування
- Використовуйте ключове слово `virtual` для методів, які мають перевизначатися
- Віртуальні функції дозволяють реалізувати поліморфізм під час виконання
- Використовуйте `override` (C++11) для явного позначення перевизначених методів

### Важливі концепції:
- **Is-a відношення**: похідний клас "є" базовим класом (Dog is an Animal)
- **Has-a відношення**: композиція (для майбутньої лабораторної)
- **Upcasting**: завжди безпечний, неявне перетворення
- **Downcasting**: може бути небезпечним, використовуйте `dynamic_cast`
- **Object slicing**: втрата даних похідного класу при копіюванні в базовий за значенням

### Компіляція:
```bash
g++ -std=c++20 -Wall -Wextra -pedantic src/task01_animal.cpp -o build/task01_animal
```

### Компіляція з RTTI (для dynamic_cast):
```bash
g++ -std=c++20 -Wall -Wextra -pedantic -frtti src/task11_casting.cpp -o build/task11_casting
```
