# Варіант 12

## Завдання 1
### Пропустити конкретне число
Завдання: Ввести `skip_value` (1 ≤ `skip_value` ≤ 30). Вивести числа від 1 до 30, пропускаючи `skip_value` за допомогою `continue`.

Ввід:
```
15
```
Вивід:
```
1 2 3 4 5 6 7 8 9 10 11 12 13 14 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
```

---

## Завдання 2
### Вивід чисел із заданою цифрою
Реалізуйте `void PrintWithDigit(const int& limit, const int& digit, const int& max_count);`. Перебирайте числа від `0` до `limit`. Якщо число не містить цифру `digit`, пропускайте `continue`. Друкуйте знайдені значення. Коли надруковано `max_count` чисел — `break`.

Ввід:
```
80
3
5
```
Вивід:
```
Matches: 3 13 23 30 31
```

---

## Завдання 3
### Об'єднання відсортованих масивів
Створіть функцію `int* MergeSorted(const int* arr1, size_t size1, const int* arr2, size_t size2, size_t& result_size);`, яка об'єднує два відсортовані масиви в один відсортований масив. Використовуйте динамічну пам'ять (`new[]`).

Приклад вводу:
```
Array1: 1 3 5 7
Array2: 2 4 6 8
```
Приклад виводу:
```
Merged: 1 2 3 4 5 6 7 8
```

---

## Завдання 4
### Лічильник об'єктів
Створіть клас `Counter` зі статичним полем `objectCount`, яке підраховує кількість створених об'єктів:
- Конструктор за замовчуванням збільшує лічильник
- Конструктор копіювання збільшує лічильник
- Деструктор зменшує лічильник
- Статичний метод `static int GetCount()` повертає кількість активних об'єктів

Приклад використання:
```cpp
std::cout << Counter::GetCount() << std::endl;  // 0
{
    Counter c1;
    Counter c2;
    std::cout << Counter::GetCount() << std::endl;  // 2
    {
        Counter c3 = c1;
        std::cout << Counter::GetCount() << std::endl;  // 3
    }
    std::cout << Counter::GetCount() << std::endl;  // 2
}
std::cout << Counter::GetCount() << std::endl;  // 0
```
