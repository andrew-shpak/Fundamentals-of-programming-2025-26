# Збірка завдань з усіх лабораторних робіт
## Fundamentals of Programming 2025-26

Цей файл містить консолідовану версію всіх завдань з лабораторних робіт курсу. Використовуйте його для підготовки до іспитів та контрольних робіт.

**Загальна кількість завдань:** 133 завдання з 15 лабораторних робіт

---

# Lab-1 — Базовий ввід/вивід

1. Вивести «Hello, World!».
2. Ввести ім'я і вивести привітання.
3. Ввести два числа і вивести їхню суму.
4. Ввести ім'я і вік, вивести: «Тобі [вік] років, [ім'я]!».
5. Ввести число і вивести його квадрат.
6. Ввести три числа, вивести їхню суму і середнє.
7. Ввести число і визначити, чи воно парне чи непарне.
8. Ввести слово і число, вивести слово задану кількість разів.
9. Ввести два числа і вивести їх у зворотному порядку.
10. Ввести два числа і вивести у форматі: a + b = результат.
11. Ввести ім'я, місто і хобі, скласти речення.

## Приклади очікуваного результату

### 1) Hello, World!
Ввід:
```
<порожньо>
```
Вивід:
```
Hello, World!
```

### 2) Привітання (ім'я)
Ввід:
```
Андрій
```
Вивід:
```
Привіт, Андрій!
```

### 3) Сума двох чисел
Ввід:
```
7 5
```
Вивід:
```
Сума: 12
```

### 4) Речення з віком
Ввід:
```
Марина
19
```
Вивід:
```
Тобі 19 років, Марина!
```

### 5) Квадрат числа
Ввід:
```
6
```
Вивід:
```
Квадрат: 36
```

### 6) Сума і середнє трьох чисел
Ввід:
```
3 6 9
```
Вивід:
```
Сума: 18
Середнє: 6
```

### 7) Парність числа
Ввід:
```
14
```
Вивід:
```
Парне
```

### 8) Повторення слова N разів
Ввід:
```
кіт
3
```
Вивід:
```
кіт
кіт
кіт
```

### 9) Два числа у зворотному порядку
Ввід:
```
10 25
```
Вивід:
```
25 10
```

### 10) Формат «a + b = результат»
Ввід:
```
7 8
```
Вивід:
```
7 + 8 = 15
```

### 11) Речення (ім'я, місто, хобі)
Ввід:
```
Оля
Київ
малювання
```
Вивід (приклад одного можливого формулювання):
```
Мене звати Оля, я з Києва, моє хобі — малювання.
```

---

# Lab-2 — Умови та цикли (if, for, while)

Нижче наведено 10 тренувальних задач з використанням операторів `if`, циклів `for` та, де доречно, `while`. Для кожної задачі подано короткий опис і приклад вводу/виводу.

## 1) Парність числа (if)
Завдання: Ввести ціле число і визначити, чи воно парне чи непарне.

- Приклад вводу: `8`
- Приклад виводу: `Число 8 є парним`

## 2) Максимум із трьох (if)
Завдання: Ввести три числа і вивести найбільше з них.

- Приклад вводу: `15 8 23`
- Приклад виводу: `Найбільше число: 23`

## 3) Таблиця множення (for)
Завдання: Ввести число n і вивести таблицю множення від 1 до 10 для цього числа.

- Приклад вводу: `7`
- Приклад виводу:
	7 × 1 = 7
	7 × 2 = 14
	7 × 3 = 21
	...
	7 × 10 = 70

## 4) Сума чисел від 1 до N (for)
Завдання: Ввести n і знайти суму всіх цілих чисел від 1 до n включно.

- Приклад вводу: `5`
- Приклад виводу: `Сума чисел від 1 до 5: 15`

## 5) Факторіал (for)
Завдання: Ввести число n (n ≥ 0) і обчислити n!.

- Приклад вводу: `5`
- Приклад виводу: `Факторіал 5! = 120`

- Примітка: обчислення 5! = 1 × 2 × 3 × 4 × 5 = 120

## 6) Реверс числа (while)
Завдання: Ввести натуральне число і вивести його цифри у зворотному порядку (наприклад, 123 → 321).

- Приклад вводу: `12340`
- Приклад виводу: `Реверс: 04321` (за бажанням можна прибирати лідируючі нулі)

- Примітка: для отримання останньої цифри використовуйте оператор остачі: `d = n % 10`,
  а для відкидання останньої цифри — цілочисельне ділення: `n = n // 10`. Повторюйте ці кроки в циклі `while (n > 0)`,
  додаючи `d` до результату. Якщо потрібно зберегти початкові нулі (як у прикладі `12340 → 04321`),
  формуйте результат як рядок або окремо обробіть кількість кінцевих нулів в оригінальному числі.

## 7) Сума цифр числа (while)
Завдання: Ввести ціле невід'ємне число та знайти суму його цифр.

- Приклад вводу: `9025`
- Приклад виводу: `Сума цифр: 16`

## 8) Кількість додатних, від'ємних і нулів (for + if)
Завдання: Ввести n, а потім n цілих чисел. Порахувати, скільки серед них додатних, від'ємних та нулів.

- Приклад вводу:
	n = 6
	Числа: `-3 0 7 -1 4 0`
- Приклад виводу: `Додатніх: 2, Від'ємних: 2, Нулів: 2`

## 9) Прості числа до N (for + if)
Завдання: Ввести n (n ≥ 2) і вивести всі прості числа від 2 до n.

- Приклад вводу: `20`
- Приклад виводу: `Прості числа до 20: 2 3 5 7 11 13 17 19`

## 10) Сума, поки не введуть 0 (while)
Завдання: Послідовно вводити цілі числа і підсумовувати їх, доки не буде введено 0. Після введення 0 — вивести суму.

- Приклад вводу: `5 3 -2 10 0`
- Приклад виводу: `Сума: 16`

**Порада:** для задач, де потрібно багато вводів, спочатку прочитайте n (кількість значень), а потім організуйте цикл на n ітерацій. Перевірки (`if`) допоможуть коректно розподіляти числа за категоріями та обробляти крайні випадки.

---

# Lab-3 — Числові типи та форматований вивід

**Важливо:** у кожній задачі користувач вводить лише одне число (ціле або дійсне).

Нижче наведені задачі з прикладами можливих запусків програми у консолі (приклади вводу/виводу). Точні тексти підказок можуть відрізнятися — головне, щоб збігався сенс результату. У завданнях зверніть увагу на використання операторів порівняння (`==`, `!=`, `<`, `>`, `<=`, `>=`), логічних операторів (`&&`, `||`, `!`).

### 1) Умова if: знак числа
Завдання: Ввести ціле число і за допомогою `if`/`else` визначити, чи воно додатне, від'ємне або дорівнює нулю.

Ввід:
```
-12
```
Вивід:
```
Number is negative
```

### 2) Цикл while: кількість цифр
Завдання: Ввести натуральне число `n` і підрахувати кількість цифр, використовуючи цикл `while` та цілочисельне ділення.

Ввід:
```
9075
```
Вивід:
```
Digits: 4
```

### 3) Цикл for: сума від 1 до n
Завдання: Ввести число `n` (`n >= 1`) і обчислити суму від 1 до `n` за допомогою класичного `for`.

Ввід:
```
5
```
Вивід:
```
Sum 1..n: 15
```

### 4) Цикл for з break: перший дільник
Завдання: Ввести число `n > 1`, пройтись по можливих дільниках у циклі `for`, знайти найменший дільник, більший за 1, та зупинити цикл через `break`. Якщо дільників немає — повідомити, що число просте.

Ввід:
```
21
```
Вивід:
```
Smallest divisor: 3
```

### 5) Цикл while: розвернути число
Завдання: Ввести невід'ємне ціле число `n` і розвернути порядок його цифр, використовуючи цикл `while`, оператор `%` та цілочисельне ділення.

Ввід:
```
4205
```
Вивід:
```
Reversed: 5024
```

### 6) Форматований вивід: площа кола
Завдання: Ввести радіус кола (дійсне число), обчислити площу `πr²` і вивести результат з двома знаками після крапки.

Ввід:
```
4.5
```
Вивід:
```
Area: 63.62
```

### 7) Робота з long long: куб числа
Завдання: Ввести ціле число `n` (|`n`| ≤ 10⁶) і вивести його куб, використовуючи тип `long long`, щоб уникнути переповнення.

Ввід:
```
-120
```
Вивід:
```
Cube: -1728000
```

### 8) Цикл for з continue: пропустити парні
Завдання: Ввести число `n` і вивести всі числа від 1 до `n`, пропускаючи парні через `continue`. Використайте логічне заперечення `!` або перевірку `==` для визначення парності; додаткових чисел користувач не вводить.

Ввід:
```
7
```
Вивід:
```
Odd numbers: 1 3 5 7
```

---

# Lab-4 — Цикли for з break/continue (частина 1)

**Важливо:** кожна програма читає рівно одне ціле число.

Нижче наведені задачі та приклади запусків. Формулювання можна адаптувати, але логіка, умови зупинки та поведінка `for`, `break`, `continue` мають зберігатися.

### 1) Зупинка на введеному числі
Завдання: Ввести значення `stop_value` (1 ≤ `stop_value` ≤ 20). Вивести числа від 1 до 20 включно та зупинитися за допомогою `break`, щойно лічильник досягне `stop_value`.

Ввід:
```
13
```
Вивід:
```
1 2 3 4 5 6 7 8 9 10 11 12 13
```

### 2) Зупинка на 15 або N
Завдання: Ввести `n` (n ≥ 1). Вивести числа від 1 до `n`, але перервати цикл на значенні 15 навіть якщо `n` більше.

Ввід:
```
18
```
Вивід:
```
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
```

### 3) Таблиця множення до порогу
Завдання: Ввести `n`. Вивести таблицю множення `n × i` для `i` від 1 до 10. Перервати цикл, коли добуток перевищить 50.

Ввід:
```
9
```
Вивід:
```
9 × 1 = 9
9 × 2 = 18
9 × 3 = 27
9 × 4 = 36
9 × 5 = 45
```

### 4) Сума з лімітом 100
Завдання: Ввести `n` (n ≥ 1). Обчислювати накопичувальну суму від 1 до `n`. Перервати цикл, якщо сума перевищила 100.

Ввід:
```
25
```
Вивід:
```
Cumulative sum: 105
Stopped at: 15
```

### 5) Пропустити конкретне число
Завдання: Ввести `skip_value` (1 ≤ `skip_value` ≤ 30). Вивести числа від 1 до 30, пропускаючи `skip_value` за допомогою `continue`.

Ввід:
```
15
```
Вивід:
```
1 2 3 4 5 6 7 8 9 10 11 12 13 14 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
```

### 6) Непарні до N
Завдання: Ввести `n` (n ≥ 1). Вивести всі непарні числа від 1 до `n`, пропускаючи парні за допомогою `continue`.

Ввід:
```
10
```
Вивід:
```
Odd numbers: 1 3 5 7 9
```

### 7) Сума парних до N
Завдання: Ввести `n` (n ≥ 1). Просумувати всі парні числа від 1 до `n`, пропускаючи непарні через `continue`.

Ввід:
```
12
```
Вивід:
```
Sum of even: 42
```

### 8) Пропустити кратні 3, зупинитися на 25
Завдання: Ввести `n` (n ≥ 1). Вивести числа від 1 до `n`, пропускаючи кратні 3 (через `continue`). Якщо лічильник досягає 25 — перервати цикл.

Ввід:
```
30
```
Вивід:
```
1 2 4 5 7 8 10 11 13 14 16 17 19 20 22 23 25
```

---

# Lab-5 — Цикли for з break/continue (частина 2)

**Важливо:** кожна програма читає рівно одне ціле число.

Нижче продовження добірки задач на `for`, `break` та `continue`. Приклади показують очікуваний стиль виводу; повідомлення можна адаптувати, зберігаючи поведінку.

### 1) Перший дільник, відмінний від 1
Завдання: Ввести натуральне `n > 1`. Пройтися `for`-циклом від 2 до `n - 1`, знайти перший дільник числа і зупинитися. Якщо дільників немає — повідомити, що число просте.

Ввід:
```
21
```
Вивід:
```
Smallest divisor: 3
```

### 2) Числа без кратних 5
Завдання: Ввести `n` (n ≥ 1). Вивести числа від 1 до `n`, пропускаючи ті, що діляться на 5, за допомогою `continue`.

Ввід:
```
16
```
Вивід:
```
1 2 3 4 6 7 8 9 11 12 13 14 16
```

### 3) Лічильник кратних 3
Завдання: Ввести `n` (n ≥ 1). Порахувати, скільки чисел від 1 до `n` діляться на 3, пропускаючи інші за допомогою `continue`.

Ввід:
```
20
```
Вивід:
```
Count divisible by 3: 6
```

### 4) Сума без кратних 4 з порогом 200
Завдання: Ввести `n` (n ≥ 1). Просумувати числа від 1 до `n`, пропускаючи ті, що діляться на 4. Перервати цикл, якщо сума перевищила 200.

Ввід:
```
40
```
Вивід:
```
Cumulative sum: 204
Stopped at: 27
```

### 5) Квадрати до ліміту 100
Завдання: Ввести `n` (n ≥ 1). Вивести квадрати чисел від 1 до `n`, пропускаючи квадрати парних чисел через `continue`. Перервати цикл, якщо квадрат перевищив 100.

Ввід:
```
15
```
Вивід:
```
1^2 = 1
3^2 = 9
5^2 = 25
7^2 = 49
9^2 = 81
```

### 6) Перші три нетривіальні дільники
Завдання: Ввести `n` (n > 1). Знайти дільники числа у проміжку від 2 до `n - 1`, пропустивши 1 та `n`. Виводити їх і зупинитися після трьох знайдених дільників або раніше, якщо їх менше.

Ввід:
```
84
```
Вивід:
```
Divisors: 2 3 4
Stopped early: true
```

### 7) Таблиця множення до виходу на 60
Завдання: Ввести `n`. Вивести таблицю множення `n × i` для `i` від 1 до 20. Якщо результат дорівнює 60 — вивести його та завершити роботу циклу (`break`). В інших випадках пропускати (`continue`) результати, що діляться на 10.

Ввід:
```
12
```
Вивід:
```
12 × 1 = 12
12 × 2 = 24
12 × 3 = 36
12 × 4 = 48
12 × 5 = 60
```

---

# Lab-6 — Цикли for з break/continue (частина 3)

**Важливо:** кожна програма читає рівно одне ціле число.
Приклади демонструють очікувану поведінку; текстові повідомлення можна адаптувати, не змінюючи логіку `for`, `break` та `continue`.

### 1) Сума кратних 7 до порогу 300
Завдання: Ввести `n` (n ≥ 7). Просумувати всі числа від 1 до `n`, що діляться на 7, пропускаючи інші за допомогою `continue`. Якщо накопичена сума перевищила 300 — вивести останній доданий множник та завершити цикл (`break`).

Ввід:
```
80
```
Вивід:
```
Cumulative sum: 315
Stopped at: 63
```

### 2) П'ять кратних 4, що не діляться на 6
Завдання: Ввести `n` (n ≥ 4). Перебрати числа від 1 до `n`, пропускаючи (`continue`) ті, що не є кратними 4 або діляться на 6. Вивести перші п'ять знайдених значень і зупинитися через `break`, як тільки лічильник досягне п'яти. Якщо значень менше, попередити про це.

Ввід:
```
40
```
Вивід:
```
Selected: 4 8 16 20 28
```

### 3) Перше число з остачами 2 (mod 5) та 1 (mod 3)
Завдання: Ввести `n` (n ≥ 2). Перебирати числа від 1 до `n`. За допомогою `continue` пропускати всі, що не дають остачу 2 при діленні на 5. Для решти знайти перше число, яке також дає остачу 1 при діленні на 3, і завершити пошук (`break`). Якщо такого числа немає — повідомити.

Ввід:
```
40
```
Вивід:
```
Found: 7
```

---

# Lab-7 — Цикли for з break/continue (частина 4)

**Важливо:** кожна програма читає рівно одне ціле число.

Нижче продовження добірки задач на `for`, `break` та `continue`. Приклади показують очікуваний стиль виводу; повідомлення можна адаптувати, зберігаючи поведінку.

### 1) Сума кратних 6 з порогом 250
Завдання: Ввести `n` (n ≥ 6). Просумувати всі числа від 1 до `n`, що діляться на 6, пропускаючи інші за допомогою `continue`. Якщо накопичена сума перевищила 250 — вивести останній доданий множник та завершити цикл (`break`).

Ввід:
```
70
```
Вивід:
```
Cumulative sum: 252
Stopped at: 66
```

### 2) Перші чотири степені двійки < N
Завдання: Ввести `n` (n ≥ 8). Знайти та вивести перші чотири степені двійки (1, 2, 4, 8, 16, ...), що менші або рівні `n`. Зупинитися через `break`, коли знайдено чотири значення або коли наступний степінь перевищує `n`.

Ввід:
```
100
```
Вивід:
```
Powers: 1 2 4 8
```

### 3) Добуток непарних до порогу 1000
Завдання: Ввести `n` (n ≥ 1). Обчислювати добуток непарних чисел від 1 до `n`, пропускаючи парні за допомогою `continue`. Перервати цикл, якщо добуток перевищив 1000.

Ввід:
```
12
```
Вивід:
```
Product: 10395
Stopped at: 11
```

### 4) Перше число Фібоначчі > N
Завдання: Ввести `n` (n ≥ 1). Генерувати послідовність Фібоначчі (починаючи з 1, 1) за допомогою циклу `for`. Перервати цикл та вивести перше число послідовності, що перевищує `n`.

Ввід:
```
50
```
Вивід:
```
First Fibonacci > 50: 55
```

### 5) Лічильник парних цифр у числі
Завдання: Ввести `n` (n ≥ 0). Порахувати кількість парних цифр у числі, пропускаючи непарні цифри за допомогою `continue`. Використати цикл для витягування цифр через `% 10`.

Ввід:
```
284635
```
Вивід:
```
Even digits: 4
```

### 6) Пропустити квадрати, зупинка на 100
Завдання: Ввести `n` (n ≥ 1). Вивести числа від 1 до `n`, пропускаючи повні квадрати (1, 4, 9, 16, 25, ...) за допомогою `continue`. Якщо лічильник досягає 100 — перервати цикл.

Ввід:
```
120
```
Вивід:
```
Non-squares: 2 3 5 6 7 8 10 11 12 13 14 15 17 18 19 20 21 22 23 24 26 27 28 29 30 31 32 33 34 35 37 38 39 40 41 42 43 44 45 46 47 48 50 51 52 53 54 55 56 57 58 59 60 61 62 63 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99
```

### 7) Перший дільник у діапазоні [5, n/2]
Завдання: Ввести `n` (n > 5). Знайти перший дільник числа `n` у діапазоні від 5 до `n/2` включно, використовуючи цикл `for` та `break`. Якщо дільників немає — повідомити про це.

Ввід:
```
45
```
Вивід:
```
First divisor: 5
```

### 8) Сума цифр з пропуском нулів
Завдання: Ввести `n` (n ≥ 0). Обчислити суму всіх цифр числа, пропускаючи нулі за допомогою `continue`. Використати цикл для витягування цифр через `% 10`.

Ввід:
```
10304
```
Вивід:
```
Digit sum: 8
```

### 9) Три числа з остачею 3 (mod 7) та непарні
Завдання: Ввести `n` (n ≥ 3). Знайти перші три непарні числа від 1 до `n`, що дають остачу 3 при діленні на 7. Пропускати парні числа та числа з іншими остачами через `continue`. Зупинитися через `break` після знаходження трьох чисел або якщо досягнуто `n`.

Ввід:
```
50
```
Вивід:
```
Found: 3 17 31
```

---

# Lab-8 — Функції з циклами for та break/continue

У цій лабораторній роботі ви потренуєтеся оголошувати та реалізовувати функції, що використовують цикли `for` з інструкціями `break` та `continue`. Кожна задача має бути реалізована як окрема функція. Створіть для кожного завдання окремий файл під `src/` (наприклад, `src/task01_sum_multiples.cpp`, `src/task02_powers.cpp`, ...).

**Важливо:** Кожна програма читає вхідні дані (одне або кілька цілих чисел) та викликає відповідну функцію для обробки.

## 1) Сума кратних числа з порогом
Реалізуйте функцію `void SumMultiples(int n, int divisor, int threshold);`, яка просумовує всі числа від 1 до `n`, що діляться на `divisor`, пропускаючи інші за допомогою `continue`. Якщо накопичена сума перевищила `threshold` — вивести останній доданий множник та завершити цикл (`break`).

Ввід:
```
70
```
Вивід (для divisor=6, threshold=250):
```
Cumulative sum: 252
Stopped at: 66
```

## 2) Кратні одного числа, але не кратні іншого
Створіть функцію `void FindSelectiveMultiples(int n, int div1, int div2, int max_count);`, яка знаходить та виводить перші `max_count` чисел від 1 до `n`, що діляться на `div1`, але НЕ діляться на `div2`. Використовуйте `continue` для пропуску непідходящих чисел та `break` для зупинки після знаходження `max_count` чисел.

Ввід:
```
100
```
Вивід (для div1=4, div2=6, max_count=5):
```
Selected: 4 8 16 20 28
```

## 3) Добуток непарних до порогу
Напишіть функцію `void ProductOdds(int n, int threshold);`, яка обчислює добуток непарних чисел від 1 до `n`, пропускаючи парні за допомогою `continue`. Перервати цикл, якщо добуток перевищив `threshold`.

Ввід:
```
12
```
Вівід (для threshold=1000):
```
Product: 10395
Stopped at: 11
```

## 4) Числа з парною сумою цифр у діапазоні
Реалізуйте функцію `void FindEvenDigitSum(int start, int end, int max_count);`, яка знаходить та виводить перші `max_count` чисел у діапазоні від `start` до `end`, у яких сума цифр є парною. Використовуйте `continue` для пропуску чисел з непарною сумою цифр та `break` для зупинки після знаходження `max_count` чисел.

Ввід:
```
10 50
```
Вивід (для max_count=5):
```
Found: 11 13 15 17 19
```

## 5) Лічильник парних цифр у числі
Створіть функцію `int CountEvenDigits(int n);`, яка повертає кількість парних цифр у числі, пропускаючи непарні цифри за допомогою `continue`. Використати цикл для витягування цифр через `% 10`.

Ввід:
```
284635
```
Вивід:
```
Even digits: 4
```

## 6) Пропустити квадрати з обмеженням
Реалізуйте функцію `void PrintNonSquares(int n, int max_count);`, яка виводить числа від 1 до `n`, пропускаючи повні квадрати (1, 4, 9, 16, 25, ...) за допомогою `continue`. Якщо лічильник досягає `max_count` — перервати цикл.

Ввід:
```
120
```
Вивід (для max_count=100):
```
Non-squares: 2 3 5 6 7 8 10 11 12 13 14 15 17 18 19 20 21 22 23 24 26 27 28 29 30 31 32 33 34 35 37 38 39 40 41 42 43 44 45 46 47 48 50 51 52 53 54 55 56 57 58 59 60 61 62 63 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99
```

## 7) Перший дільник у діапазоні
Напишіть функцію `int FindFirstDivisor(int n, int start, int end);`, яка знаходить перший дільник числа `n` у діапазоні від `start` до `end` включно, використовуючи цикл `for` та `break`. Якщо дільників немає — повернути `-1`.

Ввід:
```
45
```
Вивід (для start=5, end=22):
```
First divisor: 5
```

## 8) Сума цифр з пропуском заданої цифри
Реалізуйте функцію `int DigitSum(int n, int skip_digit);`, яка обчислює суму всіх цифр числа, пропускаючи цифру `skip_digit` за допомогою `continue`. Використати цикл для витягування цифр через `% 10`.

Ввід:
```
10304
```
Вивід (для skip_digit=0):
```
Digit sum: 8
```

## 9) Знайти k чисел з остачею та умовою парності
Створіть функцію `void FindModuloNumbers(int n, int mod, int remainder, int count, bool only_odd);`, яка знаходить перші `count` чисел від 1 до `n`, що дають остачу `remainder` при діленні на `mod`. Якщо `only_odd` = true, пропускати парні числа через `continue`. Зупинитися через `break` після знаходження `count` чисел або якщо досягнуто `n`.

Ввід:
```
50
```
Вивід (для mod=7, remainder=3, count=3, only_odd=true):
```
Found: 3 17 31
```

## Примітки

- Кожна функція повинна бути оголошена з коректною сигнатурою.
- Функції, що виводять результат, можуть мати тип `void`.
- Функції, що повертають одне значення, використовують відповідний тип (`int`, `bool` тощо).
- У `main` зчитуйте вхідні дані, викликайте функцію та виводьте результат (якщо потрібно).
- Додайте валідацію вхідних даних де це доцільно (наприклад, `n > 0`).
- Використовуйте `break` та `continue` для оптимізації та раннього виходу з циклів.

---

# Lab-9 — Цикли з параметрами-посиланнями

Цей комплект вправ тренує роботу з параметрами-посиланнями (`const int&`, `int&`, `const double&`, тощо) у поєднанні з обов'язковим використанням конструкцій `for`, `if`, `break` і `continue` всередині реалізацій.

## 1) Підрахунок кратних до потрійного збігу
Реалізуйте `int CountMultiples(const int& limit, const int& divisor);`. Переберіть значення від `1` до `limit` включно. Пропускайте числа, що не діляться на `divisor`, через `continue`. Як тільки знайдете три кратні поспіль — перервіть цикл `break`. Поверніть кількість розглянутих чисел.

Ввід:
```
30
5
```
Вивід:
```
Processed: 15
```

## 2) Сума непарних до порогу
Створіть `int SumOddUntil(const int& limit, const int& threshold);`. Цикл `for` перебирає від `1` до `limit`. Якщо число парне — `continue`. Додавайте його до накопичувача. Коли сума перевищить `threshold`, зупиніться `break` і поверніть суму.

Ввід:
```
40
120
```
Вивід:
```
Sum: 121
```

## 3) Вивід чисел із заданою цифрою
Реалізуйте `void PrintWithDigit(const int& limit, const int& digit, const int& max_count);`. Перебирайте числа від `0` до `limit`. Якщо число не містить цифру `digit`, пропускайте `continue`. Друкуйте знайдені значення. Коли надруковано `max_count` чисел — `break`.

Ввід:
```
80
3
5
```
Вивід:
```
Matches: 3 13 23 30 31
```

## 4) Пошук першого квадрату в діапазоні
Напишіть `int FirstSquareInRange(const int& start, const int& end);`. За допомогою `for` перебирайте діапазон. Якщо число не є квадратом (`i * i != value`) — одразу `continue`. Поверніть перший квадрат і зупиніться `break`. Якщо квадратів немає — поверніть `-1`.

Ввід:
```
10
30
```
Вивід:
```
First square: 16
```

## 5) Акумуляція до контролю суміжних розривів
Реалізуйте `int AccumulateWithGap(const int& limit, const int& step, const int& gap_allowance);`. Ідіть циклом `for` по арифметичній прогресії з кроком `step`. Якщо різниця між поточним і попереднім членом більша за `gap_allowance`, пропустіть значення через `continue`. Коли сумарна кількість прийнятих елементів досягне 6 — припиніть `break` і поверніть їхню суму.

## 6) Контроль балансу депозиту
Створіть `bool TrackDeposit(int& balance, const int& monthly_income, const int& risk_limit, const int& months);`. Використайте `for`, щоб по місяцях додавати `monthly_income`. Якщо баланс перевищив `risk_limit`, зменшіть його на 200 і `continue`. Якщо баланс опустився нижче 0 — `break` та поверніть `false`. Після завершення циклу поверніть `true`.

## 7) Пошук числа із заданою сумою цифр
Реалізуйте `int FindDigitSum(const int& start, const int& end, const int& target_sum, const int& max_checks);`. Перебирайте числа від `start` до `end` за допомогою `for`. Для кожного числа обчисліть суму його цифр. Якщо сума не дорівнює `target_sum` — пропустіть `continue`. При знаходженні відповідного числа поверніть його і зупиніться `break`. Якщо перевірено `max_checks` чисел або діапазон закінчився — поверніть `-1`.

Ввід:
```
100
200
10
50
```
Вивід:
```
Found: 109
```

## 8) Перевірка зростаючої послідовності цифр
Створіть `bool ValidateAscendingDigits(const int& number, int& first_violation);`. Виділяйте цифри числа справа наліво за допомогою `for` або `while`. Якщо цифра менша за попередню (рухаючись зліва направо) — збережіть її позицію у `first_violation`, зупиніться `break` і поверніть `false`. Якщо цифра дорівнює попередній — пропустіть перевірку через `continue`. Якщо всі цифри у зростаючому порядку — поверніть `true`.

Ввід:
```
12345
```
Вивід:
```
Valid: true
```

Ввід:
```
13254
```
Вивід:
```
Valid: false
Violation at position: 3
```

## 9) Підрахунок чисел із парною кількістю цифр
Напишіть `int CountEvenDigitNumbers(const int& start, const int& end, const int& target_count);`. Перебирайте числа від `start` до `end` за допомогою `for`. Для кожного числа порахуйте кількість цифр. Якщо кількість цифр непарна — пропустіть `continue`. Збільшуйте лічильник для чисел із парною кількістю цифр. Коли лічильник досягне `target_count` — зупиніться `break` і поверніть останнє оброблене число. Якщо ціль не досягнута — поверніть `-1`.

Ввід:
```
1
200
10
```
Вивід:
```
Processed up to: 19
```

## 10) Інтерактивне меню контролю
Створіть `int main()`, що показує меню з пунктами для виклику щонайменше трьох попередніх функцій. Реалізуйте цикл `for (;;)` або `for` із перевіркою. Якщо користувач вводить невідомий пункт — повідомте та `continue`. На пункт виходу — `break`. Інші пункти повинні продемонструвати роботу функцій із параметрами-посиланнями.

---

# Lab-10 — Шаблони функцій та класів (Generics)

У цій лабораторній роботі ви познайомитеся з шаблонами (templates) у C++ — механізмом узагальненого програмування, що дозволяє створювати функції та класи, які працюють з різними типами даних. Для кожного завдання створіть окрему програму, що демонструє роботу описаного шаблону.

## 1) Шаблон додавання
Створіть шаблонну функцію `template<typename T> T Add(T a, T b);`, яка повертає суму двох значень. Продемонструйте роботу з `int`, `double` та `std::string` (конкатенація).

- Приклад вводу: `5`, `3` (для int)
- Приклад виводу: `Результат: 8`

- Приклад вводу: `3.5`, `2.1` (для double)
- Приклад виводу: `Результат: 5.6`

## 2) Шаблон множення
Реалізуйте `template<typename T> T Multiply(T a, T b);`, яка повертає добуток двох значень. Перевірте роботу з цілими числами та числами з плаваючою точкою.

- Приклад вводу: `4`, `7`
- Приклад виводу: `Добуток: 28`

- Приклад вводу: `2.5`, `4.0`
- Приклад виводу: `Добуток: 10.0`

## 3) Шаблон знаходження максимуму
Напишіть `template<typename T> T Max(T a, T b);`, яка повертає більше з двох значень. Функція повинна працювати з будь-якими типами, що підтримують оператор `>`.

- Приклад вводу: `15`, `23`
- Приклад виводу: `Максимум: 23`

- Приклад вводу: `3.14`, `2.71`
- Приклад виводу: `Максимум: 3.14`

## 4) Шаблон знаходження мінімуму
Створіть `template<typename T> T Min(T a, T b);`, яка повертає менше з двох значень. Продемонструйте роботу з різними типами даних.

- Приклад вводу: `42`, `17`
- Приклад виводу: `Мінімум: 17`

- Приклад вводу: `'z'`, `'a'`
- Приклад виводу: `Мінімум: a`

## 5) Шаблон обміну значень
Реалізуйте `template<typename T> void Swap(T& a, T& b);`, яка обмінює значення двох змінних. Покажіть стан змінних до та після обміну.

- Приклад вводу: `10`, `20`
- Приклад виводу:
```
До обміну: a = 10, b = 20
Після обміну: a = 20, b = 10
```

## 6) Шаблон абсолютного значення
Реалізуйте `template<typename T> T Abs(T value);`, яка повертає абсолютне значення числа. Функція повинна працювати з `int`, `double`, `float`.

- Приклад вводу: `-42`
- Приклад виводу: `|−42| = 42`

- Приклад вводу: `-3.14`
- Приклад виводу: `|−3.14| = 3.14`

## 7) Шаблон обмеження значення
Створіть шаблонну функцію `template<typename T> T Clamp(T value, T min_val, T max_val);`, яка обмежує значення діапазоном `[min_val, max_val]`. Якщо `value < min_val`, повертає `min_val`; якщо `value > max_val`, повертає `max_val`; інакше повертає `value`.

- Приклад вводу: `150`, `0`, `100`
- Приклад виводу: `Обмежене значення: 100`

- Приклад вводу: `-5`, `0`, `100`
- Приклад виводу: `Обмежене значення: 0`

- Приклад вводу: `50`, `0`, `100`
- Приклад виводу: `Обмежене значення: 50`

---

# Lab-12 — Робота з масивами

У цій лабораторній роботі ви попрацюєте з одновимірними та багатовимірними масивами, динамічною пам'яттю, алгоритмами обробки та аналізу даних. Лабораторна складається з двох частин: базові операції з масивами та розширені алгоритми.

## Частина 1 — Базові операції з масивами

### Завдання 1 — Сума елементів масиву
Реалізуйте функцію `int Sum(const int* data, size_t length);`, яка обчислює суму всіх елементів масиву.

Приклад вводу:
```
5
1 2 3 4 5
```
Приклад виводу:
```
Сума: 15
```

### Завдання 2 — Знаходження максимуму
Напишіть функцію `int FindMax(const int* data, size_t length);`, яка повертає максимальне значення в масиві.

Приклад вводу:
```
6
3 7 2 9 1 5
```
Приклад виводу:
```
Максимум: 9
```

### Завдання 3 — Середнє арифметичне
Створіть функцію `double Average(const int* data, size_t length);`, яка обчислює середнє арифметичне елементів масиву.

Приклад вводу:
```
4
10 20 30 40
```
Приклад виводу:
```
Середнє: 25.0
```

### Завдання 4 — Підрахунок парних чисел
Реалізуйте `size_t CountEven(const int* data, size_t length);`, яка підраховує кількість парних чисел у масиві.

Приклад вводу:
```
1 2 3 4 5 6 7 8
```
Приклад виводу:
```
Парних чисел: 4
```

### Завдання 5 — Лінійний пошук
Напишіть функцію `int LinearSearch(const int* data, size_t length, int target);`, яка повертає індекс першого входження елемента або -1, якщо не знайдено.

Приклад вводу:
```
Array: 5 2 9 1 7
Target: 9
```
Приклад виводу:
```
Знайдено на позиції: 2
```

### Завдання 6 — Реверс масиву
Реалізуйте `void ReverseArray(int* data, size_t length);`, яка перевертає масив на місці.

Приклад вводу:
```
1 2 3 4 5
```
Приклад виводу:
```
5 4 3 2 1
```

### Завдання 7 — Копіювання масиву
Створіть функцію `int* CopyArray(const int* source, size_t length);`, яка створює копію масиву в динамічній пам'яті.

Приклад вводу:
```
10 20 30 40
```
Приклад виводу:
```
Оригінал: 10 20 30 40
Копія: 10 20 30 40
```

### Завдання 8 — Перевірка на відсортованість
Напишіть функцію `bool IsSorted(const int* data, size_t length);`, яка перевіряє, чи відсортований масив у порядку зростання.

Приклад вводу:
```
1 2 3 4 5
```
Приклад виводу:
```
Масив відсортовано
```

### Завдання 9 — Зсув елементів вліво
Створіть функцію `void ShiftLeft(int* data, size_t length, size_t positions);`, яка циклічно зсуває елементи вліво на `positions` позицій.

Приклад вводу:
```
Array: 1 2 3 4 5
Positions: 2
```
Приклад виводу:
```
3 4 5 1 2
```

## Частина 2 — Розширені операції з масивами

### Завдання 10 — Сума елементів матриці
Реалізуйте функцію `int SumMatrix(const int** matrix, size_t rows, size_t cols);`, яка обчислює суму всіх елементів двовимірного масиву.

Приклад вводу:
```
Rows: 3, Cols: 3
1 2 3
4 5 6
7 8 9
```
Приклад виводу:
```
Сума всіх елементів: 45
```

### Завдання 11 — Об'єднання відсортованих масивів
Створіть функцію `int* MergeSorted(const int* arr1, size_t size1, const int* arr2, size_t size2, size_t& result_size);`, яка об'єднує два відсортовані масиви в один відсортований масив. Використовуйте динамічну пам'ять (`new[]`).

Приклад вводу:
```
Array1: 1 3 5 7
Array2: 2 4 6 8
```
Приклад виводу:
```
Merged: 1 2 3 4 5 6 7 8
```

### Завдання 12 — Транспонування матриці
Напишіть функцію `int** Transpose(const int** matrix, size_t rows, size_t cols);`, яка створює і повертає транспоновану матрицю.

Приклад вводу:
```
2 3
1 2 3
4 5 6
```
Приклад виводу:
```
1 4
2 5
3 6
```

### Завдання 13 — Видалення дублікатів
Реалізуйте `int* RemoveDuplicates(const int* data, size_t length, size_t& new_length);`, яка створює новий масив без дублікатів, зберігаючи порядок першого входження.

Приклад вводу:
```
1 2 3 2 4 1 5 3
```
Приклад виводу:
```
1 2 3 4 5
```

---

# Lab-13 — Робота з рядками

У цій лабораторній роботі ви попрацюєте з C-стилем рядків (`char*`), бібліотекою `<cstring>`, а також класом `std::string`.

## Завдання 1 — Довжина рядка
Реалізуйте функцію `size_t StringLength(const char* str);`, яка обчислює довжину C-стилю рядка без використання `strlen`.

Приклад вводу:
```
Hello, World!
```
Приклад виводу:
```
Довжина: 13
```

## Завдання 2 — Реверс рядка
Напишіть функцію `void ReverseString(char* str);`, яка перевертає рядок на місці.

Приклад вводу:
```
Programming
```
Приклад виводу:
```
gnimmargorP
```

## Завдання 3 — Підрахунок голосних
Створіть функцію `size_t CountVowels(const char* str);`, яка підраховує кількість голосних літер (a, e, i, o, u) без урахування регістру.

Приклад вводу:
```
Education is important
```
Приклад виводу:
```
Голосних: 10
```

## Завдання 4 — Підрядок
Реалізуйте `char* Substring(const char* str, size_t start, size_t length);`, яка повертає новий рядок з `length` символів, починаючи з позиції `start`.

Приклад вводу:
```
String: "Programming is fun"
Start: 12, Length: 2
```
Приклад виводу:
```
is
```

## Завдання 5 — Видалення пробілів
Реалізуйте `std::string Trim(const std::string& str);`, яка видаляє пробільні символи на початку і в кінці рядка.

Приклад вводу:
```
"   Hello World   "
```
Приклад виводу:
```
"Hello World"
```

---

# Lab-15 — Основи класів, конструктори та деструктори

У цій лабораторній роботі ви навчитеся створювати класи, працювати з інкапсуляцією, конструкторами та деструкторами. Лабораторна складається з двох частин: базові концепції класів та робота з конструкторами/деструкторами.

## Частина 1 — Основи класів

### Завдання 1 — Простий клас Point з конструктором
Створіть клас `Point` з двома приватними полями `x` та `y` типу `double`. Реалізуйте:
- Конструктор `Point(double x, double y)` — ініціалізація координат
- `double GetX() const` та `double GetY() const` — отримання координат
- `void Print() const` — виведення точки у форматі `(x, y)`
- (Опціонально) `void SetX(double value)` та `void SetY(double value)` — зміна координат після створення

Приклад використання:
```cpp
Point p(3.5, 4.2);
p.Print();
std::cout << "X: " << p.GetX() << ", Y: " << p.GetY() << std::endl;
```
Приклад виводу:
```
(3.5, 4.2)
X: 3.5, Y: 4.2
```

### Завдання 2 — Клас Rectangle з конструктором
Реалізуйте клас `Rectangle` з приватними полями `width` та `height` типу `double`. Додайте:
- Конструктор `Rectangle(double w, double h)` — ініціалізація розмірів
- `double GetWidth() const` та `double GetHeight() const` — отримання розмірів
- `double CalculateArea() const` — обчислення площі
- `double CalculatePerimeter() const` — обчислення периметру

Приклад використання:
```cpp
Rectangle rect(5.0, 3.0);
std::cout << "Площа: " << rect.CalculateArea() << std::endl;
std::cout << "Периметр: " << rect.CalculatePerimeter() << std::endl;
```
Приклад виводу:
```
Площа: 15.0
Периметр: 16.0
```

### Завдання 3 — Клас Student з конструктором
Створіть клас `Student` з приватними полями:
- `std::string name`
- `int age`
- `double gpa` (середній бал)

Реалізуйте:
- Конструктор `Student(const std::string& name, int age, double gpa)` — ініціалізація студента
- Геттери для всіх полів (`GetName()`, `GetAge()`, `GetGpa()`)
- Метод `void PrintInfo() const` — виведення інформації про студента
- (Опціонально) Сеттери для зміни даних після створення

Приклад використання:
```cpp
Student s("Іван Петренко", 20, 4.5);
s.PrintInfo();
```
Приклад виводу:
```
Ім'я: Іван Петренко
Вік: 20
Середній бал: 4.5
```

### Завдання 4 — Клас BankAccount з конструктором
Реалізуйте клас `BankAccount` з приватними полями:
- `std::string accountNumber`
- `double balance`

Додайте:
- Конструктор `BankAccount(const std::string& number, double initialBalance = 0.0)` — створення рахунку
- `void Deposit(double amount)` — поповнення рахунку (перевіряти на додатність)
- `bool Withdraw(double amount)` — зняття коштів (перевіряти достатність балансу)
- `double GetBalance() const` — отримання балансу
- `std::string GetAccountNumber() const` — отримання номеру рахунку
- `void PrintStatement() const` — виведення інформації про рахунок

Приклад використання:
```cpp
BankAccount account("UA123456", 1000.0);
account.Withdraw(250.0);
account.PrintStatement();
```
Приклад виводу:
```
Рахунок: UA123456
Баланс: 750.0
```

### Завдання 5 — Використання this pointer та method chaining
Створіть клас `Point` з приватними полями `x` та `y`. Реалізуйте:
- Конструктор `Point(double x = 0.0, double y = 0.0)` — ініціалізація з параметрами за замовчуванням
- `Point& SetCoordinates(double x, double y)` — встановлює координати і повертає посилання на поточний об'єкт через `return *this`
- `Point& Move(double dx, double dy)` — зсуває точку на (dx, dy) і повертає `*this`
- `void Print() const` — виведення точки

Це дозволить використовувати method chaining:
```cpp
Point p;
p.SetCoordinates(1.0, 2.0).Move(2.0, 2.0).Print();
```
Приклад виводу:
```
(3.0, 4.0)
```

### Завдання 6 — Константні методи та об'єкти
Створіть клас `Circle` з приватним полем `radius`. Реалізуйте:
- Конструктор `Circle(double r)` — ініціалізація радіусу
- `double GetRadius() const` — отримання радіусу
- `double CalculateArea() const` — обчислення площі (π × r²)
- `double CalculateCircumference() const` — обчислення довжини кола (2 × π × r)

Використовуйте константу `M_PI` з `<cmath>`.

Приклад використання:
```cpp
const Circle c(5.0);
std::cout << "Площа: " << c.CalculateArea() << std::endl;
std::cout << "Довжина: " << c.CalculateCircumference() << std::endl;
// c.SetRadius(10.0);  // Помилка компіляції, якщо додати сеттер!
```
Приклад виводу:
```
Площа: 78.5398
Довжина: 31.4159
```

## Частина 2 — Конструктори та деструктори

### Завдання 7 — Конструктори за замовчуванням з параметрами за замовчуванням
Створіть клас `Point3D` для тривимірних точок з полями `x`, `y`, `z`. Реалізуйте:
- Конструктор з параметрами за замовчуванням: `Point3D(double x = 0.0, double y = 0.0, double z = 0.0)`
- Геттери для всіх координат
- Метод `void Print() const` — виведення у форматі `(x, y, z)`
- Метод `double DistanceFromOrigin() const` — обчислення відстані від початку координат

Один конструктор може працювати як конструктор за замовчуванням і параметризований:
```cpp
Point3D p1;              // (0, 0, 0) - викликає конструктор за замовчуванням
Point3D p2(1.0);         // (1, 0, 0)
Point3D p3(1.0, 2.0);    // (1, 2, 0)
Point3D p4(1.0, 2.0, 3.0); // (1, 2, 3)
p1.Print();
p2.Print();
```
Приклад виводу:
```
(0.0, 0.0, 0.0)
(1.0, 0.0, 0.0)
```

### Завдання 8 — Конструктор копіювання
Створіть клас `Array` для динамічного масиву цілих чисел з приватними полями:
- `int* data`
- `size_t size`

Реалізуйте:
- Конструктор `Array(size_t n)` — створює масив розміру n
- Конструктор копіювання `Array(const Array& other)` — виконує глибоке копіювання
- Деструктор `~Array()` — звільняє пам'ять
- Метод `void Set(size_t index, int value)` та `int Get(size_t index) const`

Приклад використання:
```cpp
Array arr1(5);
arr1.Set(0, 10);
Array arr2 = arr1;  // Глибоке копіювання
arr2.Set(0, 20);
```
Результат: `arr1` має 10, `arr2` має 20 на позиції 0.

### Завдання 9 — Список ініціалізації членів
Створіть клас `Person` з приватними полями:
- `const std::string name` (константне поле!)
- `int age`
- `std::string& alias` (посилання!)

Реалізуйте конструктор, який ініціалізує всі поля через список ініціалізації:
```cpp
Person(const std::string& n, int a, std::string& al)
    : name(n), age(a), alias(al) {}
```

Поясніть, чому константні поля та посилання можна ініціалізувати тільки через список ініціалізації.

### Завдання 10 — Делегуючі конструктори
Створіть клас `Rectangle` з приватними полями `width` та `height`. Реалізуйте три конструктори, що використовують делегування (C++11):
- Конструктор за замовчуванням `Rectangle()` — делегує до конструктора `Rectangle(double side)` зі значенням 1.0
- Конструктор `Rectangle(double side)` — делегує до `Rectangle(double w, double h)` з однаковими сторонами
- Головний конструктор `Rectangle(double w, double h)` — ініціалізує поля через список ініціалізації

Реалізація:
```cpp
Rectangle() : Rectangle(1.0) {}
Rectangle(double side) : Rectangle(side, side) {}
Rectangle(double w, double h) : width(w), height(h) {}
```

Додайте методи `GetArea()` та `Print()`.

Приклад використання:
```cpp
Rectangle r1;           // 1×1 квадрат
Rectangle r2(5.0);      // 5×5 квадрат
Rectangle r3(3.0, 4.0); // 3×4 прямокутник
r1.Print();
r2.Print();
r3.Print();
```
Приклад виводу:
```
Rectangle: 1.0 x 1.0, Area: 1.0
Rectangle: 5.0 x 5.0, Area: 25.0
Rectangle: 3.0 x 4.0, Area: 12.0
```

### Завдання 11 — Лічильник об'єктів
Створіть клас `Counter` зі статичним полем `objectCount`, яке підраховує кількість створених об'єктів:
- Конструктор за замовчуванням збільшує лічильник
- Конструктор копіювання збільшує лічильник
- Деструктор зменшує лічильник
- Статичний метод `static int GetCount()` повертає кількість активних об'єктів

Приклад використання:
```cpp
std::cout << Counter::GetCount() << std::endl;  // 0
{
    Counter c1;
    Counter c2;
    std::cout << Counter::GetCount() << std::endl;  // 2
    {
        Counter c3 = c1;
        std::cout << Counter::GetCount() << std::endl;  // 3
    }
    std::cout << Counter::GetCount() << std::endl;  // 2
}
std::cout << Counter::GetCount() << std::endl;  // 0
```

---

# Lab-16 — Основи наслідування

У цій лабораторній роботі ви навчитеся працювати з наслідуванням класів у C++, розумітися в ієрархіях класів, ланцюжках конструкторів та модифікаторах доступу. Лабораторна складається з двох частин: базове наслідування та розширені концепції.

## Частина 1 — Базове наслідування

### Завдання 1 — Простий приклад наслідування
Створіть базовий клас `Animal` з приватним полем `std::string name` та публічними методами:
- `Animal(const std::string& n)` — конструктор
- `void SetName(const std::string& n)` та `std::string GetName() const`
- `void Eat() const` — виводить "Тварина їсть"

Створіть похідний клас `Dog`, який успадковує `Animal` та додає метод:
- `void Bark() const` — виводить "Гав-гав!"

Приклад використання:
```cpp
Dog dog("Рекс");
dog.Eat();
dog.Bark();
```
Приклад виводу:
```
Тварина їсть
Гав-гав!
```

### Завдання 2 — Ланцюжок конструкторів
Розширте приклад з завдання 1. Додайте до класу `Animal` приватне поле `int age` та публічний метод `int GetAge() const`.

Створіть конструктор для `Dog`:
```cpp
Dog(const std::string& n, int a) : Animal(n), age(a) {}
```

Додайте метод `void PrintInfo() const` у класі `Dog`, який виводить ім'я та вік.

Приклад використання:
```cpp
Dog dog("Рекс", 3);
dog.PrintInfo();
```
Приклад виводу:
```
Ім'я: Рекс
Вік: 3 років
```

### Завдання 3 — Захищені члени класу (protected)
Створіть базовий клас `Shape` з захищеним полем `std::string color` та публічними методами:
- `Shape(const std::string& c)` — конструктор
- `std::string GetColor() const` — отримання кольору
- `void SetColor(const std::string& c)` — встановлення кольору

Створіть похідний клас `Circle` з приватним полем `double radius` та методами:
- `Circle(const std::string& c, double r)` — конструктор
- `void PrintInfo() const` — виводить колір та радіус

Продемонструйте, що похідний клас має доступ до захищеного поля `color`.

Приклад використання:
```cpp
Circle circle("червоний", 5.0);
circle.PrintInfo();
```
Приклад виводу:
```
Коло: червоний колір, радіус 5.0
```

### Завдання 4 — Перевизначення методів
Створіть базовий клас `Vehicle` з методом `void Move() const`, який виводить "Транспортний засіб рухається".

Створіть похідні класи:
- `Car` — перевизначає `Move()` для виводу "Автомобіль їде по дорозі"
- `Boat` — перевизначає `Move()` для виводу "Човен пливе по воді"
- `Plane` — перевизначає `Move()` для виводу "Літак летить у небі"

Приклад використання:
```cpp
Car car;
Boat boat;
Plane plane;
car.Move();
boat.Move();
plane.Move();
```
Приклад виводу:
```
Автомобіль їде по дорозі
Човен пливе по воді
Літак летить у небі
```

### Завдання 5 — Відношення is-a
Створіть ієрархію класів для геометричних фігур:
- Базовий клас `Shape2D` з чистими віртуальними методами `double GetArea() const` та `double GetPerimeter() const`
- Похідний клас `Rectangle` з полями `width` та `height`
- Похідний клас `Triangle` з полями `a`, `b`, `c` (сторони трикутника)

Реалізуйте обчислення площі та периметру для обох похідних класів.

Приклад використання:
```cpp
Rectangle rect(5.0, 3.0);
Triangle tri(3.0, 4.0, 5.0);
std::cout << "Площа прямокутника: " << rect.GetArea() << std::endl;
std::cout << "Площа трикутника: " << tri.GetArea() << std::endl;
```
Приклад виводу:
```
Площа прямокутника: 15.0
Площа трикутника: 6.0
```

### Завдання 6 — Доступ до членів базового класу
Створіть базовий клас `Person` з захищеними полями `name` та `age`, а також публічними методами:
- `Person(const std::string& n, int a)` — конструктор
- `void PrintInfo() const` — виводить ім'я та вік

Створіть похідний клас `Employee` з приватним полем `std::string position` та методами:
- `Employee(const std::string& n, int a, const std::string& p)` — конструктор
- `void PrintInfo() const` — перевизначає метод базового класу, виводить ім'я, вік та посаду
- Використайте `Person::PrintInfo()` всередині методу для виклику версії базового класу

Приклад використання:
```cpp
Employee emp("Марія Іванова", 28, "Розробник");
emp.PrintInfo();
```
Приклад виводу:
```
Ім'я: Марія Іванова
Вік: 28 років
Посада: Розробник
```

## Частина 2 — Розширені концепції наслідування

### Завдання 7 — Багаторівневе наслідування
Створіть ієрархію класів з трьох рівнів:
- `LivingBeing` (жива істота) з полем `bool isAlive`
- `Animal` успадковує `LivingBeing`, додає поле `int numberOfLegs`
- `Mammal` (ссавець) успадковує `Animal`, додає поле `bool hasFur` (має хутро)

Кожен клас має конструктор та метод `PrintInfo()`, який виводить всю інформацію про об'єкт.

Приклад використання:
```cpp
Mammal cat(true, 4, true);
cat.PrintInfo();
```
Приклад виводу:
```
Жива істота: так
Кількість ніг: 4
Має хутро: так
```

## Примітки

### Загальні рекомендації:
- Використовуйте модифікатор `protected` для полів, до яких потрібен доступ у похідних класах
- Завжди викликайте конструктор базового класу в списку ініціалізації похідного класу
- Слідкуйте за порядком виклику конструкторів: спочатку базовий, потім похідний
- Порядок виклику деструкторів — зворотний: спочатку похідний, потім базовий

### Для віртуальних функцій:
- Завжди оголошуйте деструктор базового класу віртуальним, якщо плануєте наслідування
- Використовуйте ключове слово `virtual` для методів, які мають перевизначатися
- Віртуальні функції дозволяють реалізувати поліморфізм під час виконання
- Використовуйте `override` (C++11) для явного позначення перевизначених методів

### Важливі концепції:
- **Is-a відношення**: похідний клас "є" базовим класом (Dog is an Animal)
- **Has-a відношення**: композиція (для майбутньої лабораторної)
- **Upcasting**: завжди безпечний, неявне перетворення
- **Downcasting**: може бути небезпечним, використовуйте `dynamic_cast`
- **Object slicing**: втрата даних похідного класу при копіюванні в базовий за значенням
