# Варіант 8

## Завдання 1
### Цикл for з break: перший дільник
Завдання: Ввести число `n > 1`, пройтись по можливих дільниках у циклі `for`, знайти найменший дільник, більший за 1, та зупинити цикл через `break`. Якщо дільників немає — повідомити, що число просте.

Ввід:
```
21
```
Вивід:
```
Smallest divisor: 3
```

---

## Завдання 2
### Сума цифр з пропуском заданої цифри
Реалізуйте функцію `int DigitSum(int n, int skip_digit);`, яка обчислює суму всіх цифр числа, пропускаючи цифру `skip_digit` за допомогою `continue`. Використати цикл для витягування цифр через `% 10`.

Ввід:
```
10304
```
Вивід (для skip_digit=0):
```
Digit sum: 8
```

---

## Завдання 3
### Перевірка на відсортованість
Напишіть функцію `bool IsSorted(const int* data, size_t length);`, яка перевіряє, чи відсортований масив у порядку зростання.

Приклад вводу:
```
1 2 3 4 5
```
Приклад виводу:
```
Масив відсортовано
```

---

## Завдання 4
### Конструктор копіювання
Створіть клас `Array` для динамічного масиву цілих чисел з приватними полями:
- `int* data`
- `size_t size`

Реалізуйте:
- Конструктор `Array(size_t n)` — створює масив розміру n
- Конструктор копіювання `Array(const Array& other)` — виконує глибоке копіювання
- Деструктор `~Array()` — звільняє пам'ять
- Метод `void Set(size_t index, int value)` та `int Get(size_t index) const`

Приклад використання:
```cpp
Array arr1(5);
arr1.Set(0, 10);
Array arr2 = arr1;  // Глибоке копіювання
arr2.Set(0, 20);
```
Результат: `arr1` має 10, `arr2` має 20 на позиції 0.
