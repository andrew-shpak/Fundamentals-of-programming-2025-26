# Лабораторна робота 12 — Робота з масивами

У цій лабораторній роботі ви попрацюєте з одновимірними та багатовимірними масивами, динамічною пам'яттю, алгоритмами обробки та аналізу даних. Лабораторна складається з двох частин: базові операції з масивами та розширені алгоритми.

Для кожного завдання створіть окремий файл під `src/` (наприклад, `src/task01_sum.cpp`, `src/task02_find_max.cpp`, …) з функцією `main`, що демонструє роботу.

---

## Частина 1 — Базові операції з масивами

### Завдання 1 — Сума елементів масиву
Реалізуйте функцію `int Sum(const int* data, size_t length);`, яка обчислює суму всіх елементів масиву.

Приклад вводу:
```
5
1 2 3 4 5
```
Приклад виводу:
```
Сума: 15
```

---

### Завдання 2 — Знаходження максимуму
Напишіть функцію `int FindMax(const int* data, size_t length);`, яка повертає максимальне значення в масиві.

Приклад вводу:
```
6
3 7 2 9 1 5
```
Приклад виводу:
```
Максимум: 9
```

---

### Завдання 3 — Середнє арифметичне
Створіть функцію `double Average(const int* data, size_t length);`, яка обчислює середнє арифметичне елементів масиву.

Приклад вводу:
```
4
10 20 30 40
```
Приклад виводу:
```
Середнє: 25.0
```

---

### Завдання 4 — Підрахунок парних чисел
Реалізуйте `size_t CountEven(const int* data, size_t length);`, яка підраховує кількість парних чисел у масиві.

Приклад вводу:
```
1 2 3 4 5 6 7 8
```
Приклад виводу:
```
Парних чисел: 4
```

---

### Завдання 5 — Лінійний пошук
Напишіть функцію `int LinearSearch(const int* data, size_t length, int target);`, яка повертає індекс першого входження елемента або -1, якщо не знайдено.

Приклад вводу:
```
Array: 5 2 9 1 7
Target: 9
```
Приклад виводу:
```
Знайдено на позиції: 2
```

---

### Завдання 6 — Реверс масиву
Реалізуйте `void ReverseArray(int* data, size_t length);`, яка перевертає масив на місці.

Приклад вводу:
```
1 2 3 4 5
```
Приклад виводу:
```
5 4 3 2 1
```

---

### Завдання 7 — Копіювання масиву
Створіть функцію `int* CopyArray(const int* source, size_t length);`, яка створює копію масиву в динамічній пам'яті.

Приклад вводу:
```
10 20 30 40
```
Приклад виводу:
```
Оригінал: 10 20 30 40
Копія: 10 20 30 40
```

---

### Завдання 8 — Перевірка на відсортованість
Напишіть функцію `bool IsSorted(const int* data, size_t length);`, яка перевіряє, чи відсортований масив у порядку зростання.

Приклад вводу:
```
1 2 3 4 5
```
Приклад виводу:
```
Масив відсортовано
```

---

### Завдання 9 — Бульбашкове сортування
Реалізуйте `void BubbleSort(int* data, size_t length);`, яка сортує масив методом бульбашки.

Приклад вводу:
```
5 2 8 1 9
```
Приклад виводу:
```
1 2 5 8 9
```

---

### Завдання 10 — Зсув елементів вліво
Створіть функцію `void ShiftLeft(int* data, size_t length, size_t positions);`, яка циклічно зсуває елементи вліво на `positions` позицій.

Приклад вводу:
```
Array: 1 2 3 4 5
Positions: 2
```
Приклад виводу:
```
3 4 5 1 2
```

---

## Частина 2 — Розширені операції з масивами

### Завдання 11 — Сума елементів матриці
Реалізуйте функцію `int SumMatrix(const int** matrix, size_t rows, size_t cols);`, яка обчислює суму всіх елементів двовимірного масиву.

Приклад вводу:
```
Rows: 3, Cols: 3
1 2 3
4 5 6
7 8 9
```
Приклад виводу:
```
Сума всіх елементів: 45
```

---

### Завдання 12 — Об'єднання відсортованих масивів
Створіть функцію `int* MergeSorted(const int* arr1, size_t size1, const int* arr2, size_t size2, size_t& result_size);`, яка об'єднує два відсортовані масиви в один відсортований масив. Використовуйте динамічну пам'ять (`new[]`).

Приклад вводу:
```
Array1: 1 3 5 7
Array2: 2 4 6 8
```
Приклад виводу:
```
Merged: 1 2 3 4 5 6 7 8
```

---

### Завдання 13 — Транспонування матриці
Напишіть функцію `int** Transpose(const int** matrix, size_t rows, size_t cols);`, яка створює і повертає транспоновану матрицю.

Приклад вводу:
```
2 3
1 2 3
4 5 6
```
Приклад виводу:
```
1 4
2 5
3 6
```

---

### Завдання 14 — Видалення дублікатів
Реалізуйте `int* RemoveDuplicates(const int* data, size_t length, size_t& new_length);`, яка створює новий масив без дублікатів, зберігаючи порядок першого входження.

Приклад вводу:
```
1 2 3 2 4 1 5 3
```
Приклад виводу:
```
1 2 3 4 5
```

---

### Завдання 15 — Пошук підмасиву
Створіть функцію `int FindSubarray(const int* array, size_t array_size, const int* sub, size_t sub_size);`, яка повертає індекс першого входження підмасиву або -1, якщо не знайдено.

Приклад вводу:
```
Array: 1 2 3 4 5 6 7
Subarray: 4 5 6
```
Приклад виводу:
```
Знайдено на позиції: 3
```

---

### Завдання 16 — Множення матриць
Реалізуйте `int** MultiplyMatrices(const int** A, size_t rowsA, size_t colsA, const int** B, size_t rowsB, size_t colsB);`, яка виконує множення двох матриць. Перевірте коректність розмірів.

Приклад вводу:
```
Matrix A (2x3):
1 2 3
4 5 6

Matrix B (3x2):
7 8
9 10
11 12
```
Приклад виводу:
```
Result (2x2):
58 64
139 154
```

---

### Завдання 17 — Знаходження медіани
Напишіть функцію `double FindMedian(int* data, size_t length);`, яка знаходить медіану масиву. Масив можна модифікувати для сортування.

Приклад вводу:
```
3 1 4 1 5 9 2 6
```
Приклад виводу:
```
Медіана: 3.5
```

---

### Завдання 18 — Спіральний обхід матриці
Реалізуйте `int* SpiralOrder(const int** matrix, size_t rows, size_t cols);`, яка повертає елементи матриці в порядку спірального обходу (за годинниковою стрілкою від зовнішнього кільця до центру).

Приклад вводу:
```
3 3
1 2 3
4 5 6
7 8 9
```
Приклад виводу:
```
1 2 3 6 9 8 7 4 5
```

---

### Завдання 19 — Розбиття масиву за умовою
Створіть функцію `size_t Partition(int* data, size_t length, bool (*predicate)(int));`, яка переставляє елементи так, щоб спочатку йшли всі елементи, що задовольняють умову, потім решта. Поверніть кількість елементів, що задовольняють умову.

Приклад вводу:
```
Array: 1 5 2 8 3 7 4
Predicate: (x % 2 == 0) — парні числа
```
Приклад виводу:
```
Partitioned: 2 8 4 1 5 3 7
Count: 3
```

---

### Завдання 20 — Динамічна зубчаста матриця
Реалізуйте структуру даних для зубчастої матриці (масив масивів різної довжини). Створіть функції:
- `int** CreateJaggedArray(const size_t* row_sizes, size_t num_rows);`
- `void PrintJaggedArray(int** jagged, const size_t* row_sizes, size_t num_rows);`
- `void DeleteJaggedArray(int** jagged, size_t num_rows);`

Приклад вводу:
```
Rows: 3
Row sizes: 2 4 3
Data:
1 2
3 4 5 6
7 8 9
```
Приклад виводу:
```
Row 0: 1 2
Row 1: 3 4 5 6
Row 2: 7 8 9
```

---

## Примітки

### Для базових завдань (1-10):
- Використовуйте статичні масиви або параметри функцій
- Фокус на правильній роботі з індексами та межами масиву
- Уникайте виходу за межі масиву
- Дотримуйтесь принципу модифікації на місці, де це зазначено

### Для розширених завдань (11-20):
- Використовуйте `new[]` та `delete[]` для роботи з динамічною пам'яттю
- Перевіряйте коректність вхідних даних (розміри масивів, nullptr)
- Слідкуйте за витоками пам'яті за допомогою valgrind або подібних інструментів
- Для багатовимірних масивів використовуйте `int**` з виділенням кожного рядка окремо
- Пам'ятайте про звільнення пам'яті після завершення роботи з масивом
